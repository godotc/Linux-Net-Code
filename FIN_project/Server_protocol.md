# 1. Web Server
就是一个服务器程序，接收请求(get,post)
浏览器就是客户端，输入地址就是进行connect
# 2. HTTP 协议（应用层）

Htpertext Transfer Protocao 

brower 发送 get,post
webserver 返回 请求结果

# 5. 服务器的基本框架

模块|功能
---|---
IO处理单元|处理客户端链接，读写网络数据
逻辑单元|业务进程或线程
网络储存单元|数据库、文件或缓存
请求队列|各单元之间的通信方式


# 6. 两种高效的事件处理模式

- 服务器通常处理三类事件： IO事件、信号、定时事件
-  有两种高效的事件处理模式： Reactor 和 Proactor
- 一般用同步IO 实现 Reactor 、 异步IO实现Proactor


## Reactor模式
##### 要求主线程（IO处理单元）只负责监听FD上是否有事件发送，有就立刻通知工作线程（逻辑单元），将socket刻度可写事件放入请求队列，交给工作线程处理，除此之外，不做任何工作。RDWD && accep && deal Request 均在工作线程中完成
---
##### 使用同步IO (以epoll_wait为例)的Reactor模式流程是：
1. **主线程**往 __epoll 内核事件表__ 中注册 socket上的读就绪事件
2. **主线程**调用 epoll_wait 等待socket上有数据可读
3. 当socket 上有数据可读时，epoll_wait通知**主线程**，主线程则将socket放入**请求队列**
4. 睡眠在请求队列上的某个**工作线程**被唤醒，它从socket读数据，处理客户的request，然后往epoll内核事件表中注册写就绪事件
5. **主线程**调用 epoll_wait 等待socket 可写
6. 当socket可写时,epoll_wait通知**主线程**，主线程将可写事件加入**请求队列**
7. 睡眠在请求队列上的某个**工作线程**被唤醒，往socket上写**用户**请求的结果

---
## Proactor模式
##### Proactor将所有IO交给主线程和内核来处理（读、写），工作线程仅仅负责业务逻辑
---
##### 使用异步IO模型（以 aio_read & aio_write为例）实现的 Proactor 模式工作流程是：

1. **主线程**调用aio_read 函数向内核注册socket上的读完成事件以后，并告诉**内核** **用户的**读缓冲区的位置，以及完成时如何通知**应用程序**(这里以信号为例）
2. **主线程**继续处理其他逻辑
3. 当socket上的数据被被内核帮助读入用户缓存区后，**内核**向**应用程序**发一个信号，以通应用程序数据已可用
4. **应用程序**预先定义好的**信号处理函数**来选择一个**工作线程**处理客户请求，**工作线程**处理完request后，调用aio_write 函数 向**内核**注册socket上的写完成事件，并告诉内核   **用户**写缓冲区的位置，以及写操作完成如何通知**应用程序**
5. **主线程**继续处理其他逻辑
6. 当用户缓冲区的数据被内核或主线程写入socket后，**内核**向**应用程序**发送一个信号，以通知数据已发送完毕
7. **应用程序**收到后，触发信号，启动预先定义好的信号处理函数选择一个工作流程来善后处理，比如决定是否关闭socket

## 模拟 Proactor 事件
###### 使用同步IO模拟出Proactor模式
##### 原理是：主线程执行读写操作，完成后向工作线程通知这一“完成事件”。那么从工作线程的角度来看，它们就直接获得了读写的结果，接下来需要做的只是对读写的记过进行逻辑处理
---
##### 使用同步IO模型 (epoll_wait为例)模拟出的Proactor模式的工作流程如下：

1. **主线程**往epoll内核事件表上组测socket上的读就绪事件
2. **主线程**调用epoll_wait 等待socket上有数据可读
3. 但socket上有数据可读时，epoll_wait通知**主线程**，主线程从socket循环读取数据，知道没有更多数据可读，然后将读到的数据**封装**成一个**请求对象** 插入请求队列
4. 睡眠的**工作线程**被唤醒，处理requset，然后往epoll内核事件表中注册socket上的写就绪事件
5. **主线程**用 epoll_wait 等待 socket 可写
6. 当socket可写时，epoll_wait 通知主线程。 **主线程**往socket上写入服务的返回的 requset 结果


# 7.线程池
- 服务器预先创建的一组子线程，数量应该和cpu数量差不多

- 主线程通过某种算法来主动选择子线程。最简单，最常用的算法是随机算法和 Round Robin(轮流选取)算法，但更优秀的、只能的算法使工作线程中更均匀的分配，从而减轻服务器的整体压力

- 主线程和所有子线程通过一个共享的共享的工作队列来同步，子线程都睡在工作队列上。

###### cpu密集型(视频剪辑等) 线程数 应与硬件cpu 线程数一样（或+1），防止线程阻塞
###### 对于IO密集型（如消息应答）应该多于cpu线程数，因为争夺的是IO，IO的处理非常慢，多余cores数的线程将为菜谱争取更多的人物，不至于在处理IO的过程中，cpu空闲而资源浪费
---
##### 概述
- 空间换时间，浪费服务器的硬件资源，换取运行效率
- 池是一组资源的集合，这组资源在服务器启动之初就被完全创建好并初始化好，这叫做静态资源
- 当服务器进入正式运行阶段，开始处理客户请求的时候，如果它需要相关的资源，可以直接从池中获取，无需动态分配。
- 当服务器处理完一个客户连接后，可以把相关的资源放回池中，无需执行系统调用释放资源。


# 8.有限状态机

Finite State Machine

根据应用层协议包含**数据包类型**字段,服务器可以根据它**映射**的一种执行状态来编写响应的逻辑；
